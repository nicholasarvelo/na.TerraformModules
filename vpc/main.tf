locals {
  # This local is a map where the keys are indices of private subnet CIDR
  # blocks declared in 'var.subnet_cidr_blocks'. This local is then used in the
  # 'aws_subnet' resource block to iterate over and create private subnets.
  private_cidr_block = {
    for index, cidr_block in var.subnet_cidr_blocks["private"] :
    index => {
      index      = index
      cidr_block = cidr_block
    }
  }

  # This local is a map that ensures that each subnet in
  # 'local.private_cidr_block' is associated with a specific availability zone
  # when creating the aws_subnet resource for private subnets.
  private_availability_zone = {
    for key, value in local.private_cidr_block :
    key => element(data.aws_availability_zones.this.names, value.index)
  }

  # This local is a map where the keys are indices of public subnet CIDR
  # blocks declared in 'var.subnet_cidr_blocks'. This local is then used in the
  # 'aws_subnet' resource block to iterate over and create public subnets.
  public_cidr_block = {
    for index, cidr_block in var.subnet_cidr_blocks["public"] :
    index => {
      index      = index
      cidr_block = cidr_block
    }
  }

  # This local is a map that ensures that each subnet in
  # 'local.public_cidr_block' is associated with a specific availability zone
  # when creating the aws_subnet resource for public subnets.
  public_availability_zone = {
    for key, value in local.public_cidr_block :
    key => element(data.aws_availability_zones.this.names, value.index)
  }

  is_private_cidr_list_empty = length(var.subnet_cidr_blocks["private"]) == 0
  is_public_cidr_list_empty  = length(var.subnet_cidr_blocks["public"]) == 0
  nat_requirements_met = (
    local.is_private_cidr_list_empty == false &&
    local.is_public_cidr_list_empty == false
  )
}

# This resource block creates a Virtual Private Cloud (VPC). While it's not
# explicitly listed in this resource block, upon creation of this VPC, AWS
# automatically generates a default route table which controls the routing for
# all subnets that don't have an explicit route table.
resource "aws_vpc" "this" {
  cidr_block           = var.vpc_cidr_block
  enable_dns_hostnames = true

  tags = {
    Name = var.vpc_name
  }
}

# Unlike other resource blocks, this one doesn't create a default route table.
# Instead, it adopts the default route table automatically generated by the
# 'aws_vpc' resource block. The primary reason for this adoption is to apply
# tags to the default route table.
resource "aws_default_route_table" "this" {
  default_route_table_id = aws_vpc.this.default_route_table_id

  tags = {
    Name = format("%s-main-route-table", var.vpc_name)
  }
}

# This resource loops through each private CIDR block and creates a subnet for
# each.
resource "aws_subnet" "private" {
  for_each          = local.private_cidr_block
  vpc_id            = aws_vpc.this.id
  cidr_block        = local.private_cidr_block[each.key]["cidr_block"]
  availability_zone = local.private_availability_zone[each.key]

  tags = {
    Name = (
      format(
        "%s-private-%s",
        var.vpc_name,
        local.private_availability_zone[each.key]
      )
    )
  }
}

# This resource creates an Elastic IP which is a static, public IPv4 address
# that can be dynamically associated with any instance or network interface
# within your VPC. This Elastic IP is assigned to the NAT gateway.
resource "aws_eip" "this" {
  count  = local.nat_requirements_met ? 1 : 0
  domain = "vpc"
}

# This resource creates a NAT gateway which enables instances in a private
# subnet to connect to the internet or other AWS services, but prevents the
# internet from initiating a connection with those instances.
# A NAT gateway requires the presence of at least one private subnet and one
# public subnet before it can be created.
resource "aws_nat_gateway" "this" {
  count         = local.nat_requirements_met ? 1 : 0
  allocation_id = aws_eip.this[0].id
  subnet_id     = aws_subnet.public[0].id

  tags = {
    Name = (
      format(
        "%s-nat-public-%s",
        var.vpc_name,
        aws_subnet.public[0].availability_zone
      )
    )
  }
}

# This resource block creates a route table for each private subnet created by
# the 'aws_subnet.private' resource block. If a NAT gateway is created, each
# route table will include a route that directs all outbound traffic to this
# NAT gateway.
resource "aws_route_table" "private" {
  for_each = aws_subnet.private
  vpc_id   = aws_vpc.this.id

  dynamic "route" {
    for_each = aws_nat_gateway.this
    content {
      cidr_block     = "0.0.0.0/0"
      nat_gateway_id = aws_nat_gateway.this[0].id
    }
  }

  tags = {
    Name = format("%s", aws_subnet.private[each.key].tags.Name)
  }
}

# This resource block associates each private subnet with the corresponding
# route table created by the 'aws_route_table.private' resource block.
resource "aws_route_table_association" "private" {
  for_each       = aws_subnet.private
  subnet_id      = aws_subnet.private[each.key].id
  route_table_id = aws_route_table.private[each.key].id
}

# This resource block is creating a S3 service VPC endpoint. A VPC endpoint
# provides private connections between the VPC and the specified AWS service
# (S3 in this case) without requiring access over the internet.
# This VPC Endpoint is only created if private subnets are present.
resource "aws_vpc_endpoint" "this" {
  count        = local.is_private_cidr_list_empty ? 0 : 1
  service_name = format("com.amazonaws.%s.s3", var.aws_region)
  vpc_id       = aws_vpc.this.id

  tags = {
    Name = format("%s-s3-vpc-endpoint-gateway", var.vpc_name)
  }
}

# This block associates the VPC endpoint created by the 'aws_vpc_endpoint'
# resource block with each private route table created by the
# 'aws_route_table.private' resource block. These associations allow traffic
# to be directed from the VPC to the S3 service through the VPC endpoint.
resource "aws_vpc_endpoint_route_table_association" "this" {
  for_each        = aws_route_table.private
  route_table_id  = aws_route_table.private[each.key].id
  vpc_endpoint_id = aws_vpc_endpoint.this[0].id
}

# This resource loops through each public CIDR block and creates a subnet for
# each.
resource "aws_subnet" "public" {
  for_each          = local.public_cidr_block
  vpc_id            = aws_vpc.this.id
  cidr_block        = local.public_cidr_block[each.key]["cidr_block"]
  availability_zone = local.public_availability_zone[each.key]

  tags = {
    Name = (
      format(
        "%s-public-%s",
        var.vpc_name,
        local.public_availability_zone[each.key]
      )
    )
  }
}

# This resource block is creating an Internet Gateway and attaching it to the
# VPC created by the 'aws_vpc' resource block. An internet gateway acts as a
# bridge between a VPC's resources and the public internet.
# An internet gateway is different from a NAT gateway in that an internet
# gateway allows instances in a public subnet to connect to the internet while
# a NAT Gateway allows instances in a private subnet to connect to the internet
# while preventing the internet from initiating a connection with those
# same instances.
resource "aws_internet_gateway" "this" {
  count  = local.is_public_cidr_list_empty ? 0 : 1
  vpc_id = aws_vpc.this.id

  tags = {
    Name = format("%s-internet-gateway", var.vpc_name)
  }
}

# This resource block creates a route table for each public subnet created by
# the 'aws_subnet.public' resource block. If an internet gateway is created,
# each route table will include a route that directs all outbound traffic to
# this internet gateway.
resource "aws_route_table" "public" {
  count  = local.is_public_cidr_list_empty ? 0 : 1
  vpc_id = aws_vpc.this.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.this[0].id
  }

  tags = {
    Name = format("%s-public-route-table", var.vpc_name)
  }
}

# This resource block associates each public subnet with the corresponding
# route table created by the 'aws_route_table.public]' resource block.
resource "aws_route_table_association" "public" {
  for_each       = aws_subnet.public
  subnet_id      = aws_subnet.public[each.key].id
  route_table_id = aws_route_table.public[0].id
}
